---
layout: post
title: "什么是堆？什么是栈？"
description: ""
category: 
tags: [heap,stack]
---

一、英文名称

堆和栈是C/C++编程中经常遇到的两个基本概念。先看一下它们的英文表示：
	
	堆――heap
	栈――stack

二、从数据结构和系统两个层次理解

在具体的C/C++编程框架中，这两个概念并不是并行的。深入到汇编级进行研究就会发现，栈是机器系统提供的数据结构，而堆是由C/C++函数库提供的。这两个概念可以从数据结构和系统两个层次去理解：

1、从数据结构层次理解，栈是一种先进后出的线性表，只要符合先进后出的原则的线性表都是栈。至于采用的存储方式（实现方式）是顺序存储（顺序栈）还是链式存储（链式栈）是没有关系的。堆则是二叉树的一种，有最大堆最小堆，排序算法中有常用的堆排序。

2、从系统层次理解，栈是系统为运行的程序分配的先进后出的存储区域。在学习bootloader时知道，在上电后初始化阶段要为各个工作模式下分 配堆栈，这里的堆栈实际上就是指stack，堆栈的说法只是因为历史的原因。在执行函数时，函数内部局部变量的存储单元可以在栈上创建（针对CISC架构 而言，RISC架构下，局部变量的存储单元是在寄存器上创建），函数执行结束时这些存储单元自动被释放。堆是系统管理的可以被程序利用的全局存储空间，动 态内存分配就是从堆上分配。

具体地说，现在计算机（串行执行机制），都直接在代码层次支持栈这种数据结构。这体现在，有专门的寄存器指向栈所在的地址，有专门的机器指令完成数据入栈 出栈的操作。比如ARM指令中的stmfd和ldmfd。因为栈内存分配运算内置于处理器的指令集中，所以效率很高，但是支持的数据有限，一般是整数、指 针、浮点数等系统直接支持的数据类型，并不直接支持其他的数据结构。在CISC中，对子程序的调用就是利用栈来完成的。C/C++中的自动变量也是直接利 用栈的例子，这就是为什么当函数返回时，该函数的自动变量失效的原因（因为栈恢复了调用前的状态）。在RISC下，这些都是通过寄存器来完成的。这些留待 第二部分总结中详细阐述。

和栈不同，堆的数据结构并不是由系统（无论是机器系统还是操作系统）支持的，而是由函数库提供的。基本的malloc/free函数维护了一套内部的堆数 据结构。当程序使用这些函数去获得新的内存空间时，这套函数首先试图从内部堆中寻找可用的内存空间。如果没有可用的内存空间，则试图利用系统调用来动态增 加程序数据段的内存大小，新分配得到的空间首先被组织进内部堆中去，然后再以适当的形式返回给调用者。当程序释放分配的内存空间时，这片内存空间被返回内 存堆结构中，可能会被适当的处理（比如和其他空闲空间合并成更大的空闲空间），以更适合下一次内存分配申请。这套复杂的分配机制实际上相当于一个内存分配 的缓冲池（cache），使用这套机制有如下原因：

1、系统调用可能不支持任意大小的内存分配。有些系统的系统调用只支持固定大小及其倍数的内存请求（按页分配），这样的话对于大量的小内存分类来说会造成浪费
2、系统调用申请内存可能是代价昂贵的，因为这可能涉及到用户态和核心态的转换
3、没有管理的内存分配在大量复杂内存的分配释放操作下很容易造成内存碎片

总结：

1、栈是系统提供的功能，特点是快速高效，缺点是有限制，数据不灵活；而堆是函数库提供的功能，特点是灵活方便，数据适应面广泛，但是效率有一定降低
2、栈是系统数据结构，对于进程/线程是唯一的；堆是函数库内部数据结构，不一定唯一，不同堆分配的内存无法互相操作
3、栈空间分静态分配和动态分配两种。静态分配是编译器完成的，比如自动变量(auto)的分配。动态分配由alloc函数完成。栈的动态分配无需释放 (是自动的)，也就没有释放函数。为可移植的程序起见，栈的动态分配操作是不被鼓励的！堆空间的分配总是动态的，虽然程序结束时所有的数据空间都会被释放 回系统，但是精确的申请内存/释放内存匹配是良好程序的基本要素

三、从系统层次再次细化分析
     
下面从系统的层次对堆和栈再次进行细致的对比，以更好的理解这两个概念。

1、申请方式

stack：系统自动分配。
heap：程序员自己申请，指明大小。

2、申请后系统响应

stack：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
heap：首先 应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链 表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正 确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

3、申请大小的限制

stack：在ARM中，stack预先设置好。在start.S中，可以有四种不同的栈：满栈递增，满栈递减，空栈递增，空栈递减。常用的是满栈递减，就是向下（低地址）方向生长。如果分析bootloader的stack设置部分，这个很容易理解。 
heap：是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

4、申请效率比较

stack：由系统自动分配，速度较快。但程序员是无法控制的。
heap：由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。

5、存储内容

stack：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各 个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是 参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。   
heap：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。

6、存取效率比较

stack：在运行时刻赋值，存取效率高。   
heap：在编译时就确定，存取效率不如stack。

因为栈是由系统分配，更为确切的说，这就与CPU是RISC架构还是CISC架构密切相关的。在两种不同指令集体系结构中，对待内存分配的处理上是明显不 同的。在RISC架构下，原则之一就是尽量少访问内存，而代之以寄存器解决。所以寄存器的数目要明显多于CISC架构的寄存器。而堆是由函数库来提供的， 与系统的关系就远了。

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

简单的可以理解为：

heap：是由malloc之类函数分配的空间所在地。地址是由低向高增长的。
stack：是自动分配变量，以及函数调用的时候所使用的一些空间。地址是由高向低减少的。

预备知识—程序的内存分配

一个由c/C++编译的程序占用的内存分为以下几个部分
1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。
3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放
4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放
5、程序代码区—存放函数体的二进制代码。

二、例子程序

这是一个前辈写的，非常详细

	//main.cpp
	int a = 0; //全局初始化区
	char *p1;  //全局未初始化区
	main()
	{
		int b; //栈
		char s[] = "abc"; //栈
		char *p2; //栈
		char *p3 = "123456"; //123456在常量区，p3在栈上。
		static int c =0； //全局（静态）初始化区
		p1 = (char *)malloc(10);
		p2 = (char *)malloc(20);
		//分配得来得10和20字节的区域就在堆区。
		strcpy(p1, "123456"); //123456放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。
	}


二、堆和栈的理论知识

2.1 申请方式

stack:
由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间

heap:
需要程序员自己申请，并指明大小，在c中malloc函数

如p1 = (char *)malloc(10);
在C++中用new运算符
如p2 = (char *)malloc(10);
但是注意p1、p2本身是在栈中的。

2.2 申请后系统的响应

栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大 小，系统会自动的将多余的那部分重新放入空闲链表中。

2.3 申请大小的限制

栈：在Windows下,栈是向低地址扩展的数据结构，是一块 连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因 此，能从栈获得的空间较小。

堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

2.4 申请效率的比较：

栈由系统自动分配，速度较快。但程序员是无法控制的。
堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.
另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度， 也最灵活。

2.5 堆和栈中的存储内容

栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。
当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。

堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。

2.6存取效率的比较

	char s1[] = "aaaaaaaaaaaaaaa";
	char *s2 = "bbbbbbbbbbbbbbbbb";

aaaaaaaaaaa是在运行时刻赋值的；
而bbbbbbbbbbb是在编译时就确定的；
但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。
比如：

	#include
	void main()
	{
	char a = 1;
	char c[] = "1234567890";
	char *p ="1234567890";
	a = c[1];
	a = p[1];
	return;
	}

对应的汇编代码

	10: a = c[1];
	00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh]
	0040106A 88 4D FC mov byte ptr [ebp-4],cl
	11: a = p[1];
	0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]
	00401070 8A 42 01 mov al,byte ptr [edx+1]
	00401073 88 45 FC mov byte ptr [ebp-4],al

第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指edx中，在根据edx读取字符，显然慢了。

2.7 小结：

堆和栈的区别可以用如下的比喻来看出：
使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。
使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。

堆和栈的区别主要分：

操作系统方面的堆和栈，如上面说的那些，不多说了。
还有就是数据结构方面的堆和栈，这些都是不同的概念。这里的堆实际上指的就是（满足堆性质的）优先队列的一种数据结构，第1个元素有最高的优先权；栈实际上就是满足先进后出的性质的数学或数据结构。
虽然堆栈，堆栈的说法是连起来叫，但是他们还是有很大区别的，连着叫只是由于历史的原因
