---
layout: post
title: "开始使用C++11的9个理由"
description: ""
category: Geek
tags: [C++11]
---
{% include JB/setup %}

如果你的代码工作正常并且表现良好，你可能会想知道为什么还要使用C++ 11。当然了，使用用最新的技术感觉很好，但是事实上它是否值得呢？ 在我看来，答案毫无疑问是肯定的。我在下面给出了9个理由，它们分为两类：性能优势和开发效率。

## 获得性能优势

理由1：move语义(move semantics)。简单的说，它是优化复制的一种方式。有时候复制很显然是浪费的。如果你从一个临时的string对象复制内容，简单的复制指针到字符缓冲区将比创建一个新的缓冲区再复制要高效得多。他之所以能工作是因为源对象超出了范围。

然而，在这以前C++并没有判断源对象是不是临时对象的机制。move语义通过除了复制操作外还允许你有一个move构造函数(move constructor)和一个move赋值运算(move assignment)符来提供这个机制。

你知道吗？当你在Visual Studio 2010中使用标准库中的类如string或vector时，它们已经支持move语义了。这可以防止不必要的的复制从而改善性能。

通过在你的类中实现move语义你可以获得额外的性能提升，比如当你把它们存储到STL容器中时。还有，move语义不仅可以应用到构造函数，还可以应用到方法（如vector的push_back方法）。

理由2：通过使用类别属性(type traits,如is_floating_point)和模板元编程(template metaprogramming，如enable_if template)，你可以为某些特定的类型定制模版，这可以实现优化。

理由3：哈希表现在已经是标准实现的了，它提供更快速的插入、删除和查找，这在处理大量数据时很有用。你现在可以随便使用unordered_map, unordered_multimap, unordered_set 和unordered_multiset这几种数据结构了。

## 提高效率

提高效率不仅都是在代码性能方面，开发时间也是宝贵的。C++ 11可以让你的代码更短、更清晰、和更易于阅读，这可以让你的效率更高。

理由4：auto关键字可以自动推断类型，所以下面的代码：

    vector<vector<MyType>>::const_iterator it = v.begin() 

现在可以很简单的写成：

    auto it = v.cbegin() 

尽管有些人会说，它隐藏了类型信息，在我看来它利大于弊，因为它减少了视觉混换并展示了代码的行为，还有它可以让你我少打很多字！

理由5：Lambda表达式提供了一种方法来定义匿名方法对象（实际上是闭包），这是代码更加线性和有规律可循。这在和STL算法结合使用时很方便：

	bool is_fuel_level_safe()
	{    
	    return all_of(_tanks.begin(), _tanks.end(),         
	        [this](Tank& t) { return t.fuel_level() > _min_fuel_level; });
	}

理由6：新的智能指针（smart pointer）替换了有问题的auto_ptr，你可以不用担心内存的释放并移除相关释放内存的代码了。这让代码更清晰，并杜绝了内存泄露和查找内存泄露的时间。

理由7：把方法作为first class object是一个非常强大的特性，这让你的代码变得更灵活和通用了。C++的std::function提供了这方面的功能。方法提供一种包装和传递任何可调用的东西-函数指针, 仿函数（functor）, lambda表达式等。

理由8：还有许多其它小的功能，如override、final关键字和nullptr让你的代码意图更明确。对我来说，减少视觉混乱和代码中能够更清楚地表达我的意图意味着更高兴、更高效。

另一个开发效率的方面是错误检测。如果你的错误在运行时发生，这意味着你至少需要运行软件，并可能得通过一系列步骤来重现错误，这需要时间。

C++ 11提供了一种方法来检查先决条件并尽早的在可能的时机捕获错误-编译过程中，在你运行代码前。这就是理由9。

这是通过静态断言(static_assert)和类别属性模版实现的。这种方法的另一个好处是，它不需要占用任何的运行时开销，没有什么性能损失！

## 现在开始掌握C++ 11

在C++ 11标准中除了上描述的还有更多的改动和新功能，它需要一整本数来描述。不过，我相信它们是值得你花时间去学习的。你将省去以往花在提高效率上的时间。很多主流的编译器已经开始支持C++ 11的一些标准了。还等什么？开始吧！


英文出自：[cpprocks](http://cpprocks.com/9-reasons-to-start-using-c11/)

译文出自：[开源中国社区](http://www.oschina.net/news/28928/9-reasons-to-start-using-c11)
